# -*- coding: utf-8 -*-
"""faceRep.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1wKeKL39RvsuPiMI4-W1AZrUUgrEyy5FY
"""

# Commented out IPython magic to ensure Python compatibility.
# %pip install nengo
import numpy as np
import gzip
import matplotlib.cm as cm
import matplotlib.pyplot as plt
import nengo
from nengo.utils.ensemble import response_curves, tuning_curves
import tqdm
import pickle
# %matplotlib inline

import os
import imageio
def read_image_database(path='faces.npz'):
    images = []
    for file in os.listdir(path):
        images.append(imageio.imread(os.path.join(path,file), as_gray=True))
    mat = np.array(images, dtype=np.uint8)
    return mat

mat = np.load('faces.npz')['arr_0'].astype(np.float64)

def half_resolution(X,rep=1):
    for _ in range(rep):
        r,c = 2*(X.shape[0]//2), 2*(X.shape[1]//2)
        X = 0.25*(X[:r:2, :c:2] + X[1:r:2, 1:c:2] + X[1:r:2, :c:2] + X[:r:2, 1:c:2])
    return X

images_small = []
for i in range(mat.shape[0]):
    images_small.append(half_resolution(mat[i], 2))
mat = np.array(images_small)
X = (2.0 * mat/255.0-1.0)

N = mat.shape[0]
h = mat.shape[1]
w = mat.shape[2]

X = X.reshape(N, w*h)
X_zero_mean = X-np.mean(X,axis=0)
X_cov = (X_zero_mean.T @ X_zero_mean)/(X.shape[0]-1)
D,V = np.linalg.eigh(X_cov)
D = D[::-1]
V = V.T[::-1,:]
V = V / np.linalg.norm(V,axis=0)

numEigenfaces = 15
encoders = V[:numEigenfaces]
#numCombs = (h*w)-numEigenfaces
#combs = genRandomLinearCombinations(encoders, (h*w)-numEigenfaces)
#E = np.concatenate((encoders, combs))

# want to keep the same ensemble and see how it represents faces
# if we reinitialze the ensemble for each input, then the curves
# are meaningless 
def Model(X, numNeu, d, E,synap, T, isPlot):
    lenX = len(X)
    populationCurves = []
    representations = []
    sts = []
    model = nengo.Network(seed=581)
    with model:
        ensA = nengo.Ensemble(n_neurons=numNeu,dimensions=d,encoders=E.T,normalize_encoders=False)
    for i in range(len(X)):
        with model:
            inp = nengo.Node(X[i])
            il = nengo.Connection(inp,ensA.neurons)
            inpProbe = nengo.Probe(inp)
            spikes = nengo.Probe(ensA.neurons)
            voltage = nengo.Probe(ensA.neurons, 'voltage')
            filtered = nengo.Probe(ensA,synapse=synap)
        with nengo.Simulator(model, progress_bar=False, optimize=True) as sim:
            if i%10==0: print("running simulation for step:",i)
            sim.run(T)
            # x_axis = 50 x vals
            # y_axis = n_neurons * 50 y values
            responseCurves = response_curves(ensA,sim)
            populationCurves.append(responseCurves)
            representations.append(responseCurves[1])
            sts.append(sim.data[filtered].T)
            if isPlot:
                plt.subplot(12,7,i+1)
                plt.plot(sim.trange(), sim.data[filtered])
    plt.show()
    return populationCurves, representations, sts

def plotImages(X):
    NN = int(np.floor(np.sqrt(len(X))))
    fig,axs = plt.subplots(NN,NN,figsize=(5.5,7))
    for i in range(NN):
        for j in range(NN):
            axs[i,j].imshow(X[NN*i+j].reshape(h,w),cmap='gray')
            axs[i,j].set_xticks([])
            axs[i, j].set_yticks([])
    fig.tight_layout(w_pad=0.0,h_pad=0.0)

def zeroHorizontal(X,s,e):
    for x in X:
        for i in range(s,e):
            x[i] = -1
    return X

"""## First get neural response for origianl face data"""

# curves1,reps1,st1 = Model(X=X,numNeu=2700,d=15,E=encoders,synap=0.01,T=0.1,isPlot=0)
# afile = open(r'st1.pkl', 'wb')
# pickle.dump(st1, afile)
# afile.close()
"""## Experiment 1: subtract mean face

We run this experiment to see if the neural response of our population will have less overlap, if the original inputs have less overlap. And depending on which output signals are better, we will use them to compare to the rest of our experiments.
"""

meanFace = np.mean(X,axis=0)
X1 = [x-meanFace for x in X]
# plotImages(np.array(X).reshape(84,60,45))
# plotImages(np.array(X1).reshape(84,60,45))

# curvesX1,repsX1,stX1 = Model(X=X1,numNeu=2700,d=15,E=encoders,synap=0.01,T=0.1,isPlot=0)
# afile = open(r'stX1.pkl', 'wb')
# pickle.dump(stX1, afile)
# afile.close()
"""## Experiment 2: drastically darkening skin colour

Will perform the following by deconstructing each face's PCA weights, and increasing the weight that corresponds to PC2, and reconstructing the face.
"""

# get weights [w1,w2,...,wn] where n is 2700, by computing [PCi * (Xi - meanFace)] for i in range(1,n)
# note we use all n weights to reconstruct the image after amplifying PC2, because we do not want to
# reduce image quality here, we just want to adjust a certain component of the image.
def getWeights(X, PCs, meanFace):
    weights = []
    for i in range(len(X)):
        w = PCs[i] * (X[i] - meanFace)
        weights.append(w)
    return weights

# i is the ith component we would like to darken
def darkenComponent(i,weights,factor):
    for w in weights:
        w[i] *= -factor if w[i]>0 else factor
        if w[i] < -1: w[i] = -1
            
def reconstructFaces(weights,PCs):
    faces = []
    for ws in weights:
        face = np.zeros(len(ws))
        for w,pc in zip(ws,PCs):
            face += w*pc
        faces.append(face)
    return faces
#weights = getWeights(X,V,meanFace)
#darkenComponent(1, weights, 1)
#X2 = reconstructFaces(weights,V)

## ^ above reconstruction method did not work so we will just add more of a component to all our faces.
def changeComponent(change,i, PCs, originalFaces, factor):
    newFaces = []
    for f in originalFaces.reshape(N,h*w):
        newFace = f - factor*PCs[i] if change=="darken" else f +factor*PCs[i]
        newFaces.append(newFace)
    return newFaces
X2 = changeComponent("darken",0,V,X,15)
# plotImages(np.array(X2).reshape(N,h,w))

# curvesX2,repsX2,stX2 = Model(X=X2,numNeu=2700,d=15,E=E,synap=0.01,T=0.1,isPlot=0)
# afile = open(r'stX2.pkl', 'wb')
# pickle.dump(stX2, afile)
# afile.close()


"""## Experiment 3: drastically brighten skin colour"""

X3 = changeComponent("brighten",0,V,X,15)
curvesX3,repsX3,stX3 = Model(X=X3,numNeu=2700,d=15,E=encoders,synap=0.01,T=0.1,isPlot=0)

afile = open(r'stX3.pkl', 'wb')
pickle.dump(stX3, afile)
afile.close()
